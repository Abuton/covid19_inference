# ------------------------------------------------------------------------------ #
# @Author:        Sebastian B. Mohr
# @Email:
# @Created:       2020-05-26 13:09:09
# @Last Modified: 2020-06-04 17:43:53
# ------------------------------------------------------------------------------ #

from .model import *
from scipy.stats import lognorm
import numpy as np

import logging

log = logging.getLogger(__name__)


def RungeKutta4(dt, f, t, y_t):
    """
        Performs runge kutta 4 on a function with parameters

        Parameters
        ----------
        dt : number
            size of the timestep
        f : function
            function on which the runge kutta steps should be performed
        t : number
            time
        y : array
            state vector at time t
    """
    k_1 = f(t, y_t)
    k_2 = f(t + dt / 2, y_t + k_1 * dt / 2)
    k_3 = f(t + dt / 2, y_t + k_2 * dt / 2)
    k_4 = f(t + dt, y_t + k_3 * dt)
    return y_t + dt / 6 * (k_1 + 2 * k_2 + 2 * k_3 + k_4)


@use_model_ctx
def SIR(lambda_t, model=None):
    """
        Calculates a SIR model by computing the next timesteps via. Runge Kutta 4. 
        Adds a time dependent lambda array to the SIR model.

        Parameters
        ----------
        lambda_t : array
            Should be generated by one of the model lambda functions for the right size
        model : model
            The dummy model to use. Can be none for the last used model

        Return
        ------
        t , S, I, R
    """
    # SIR model as vector
    def f(t, y_t):
        """
        The function for the SIR model

        Parameters
        ----------
        t: number
            current timestep
        y: array
            SIR state vector [S,I,R,lambda]
        """
        S = y_t[0]
        I = y_t[1]
        R = y_t[2]
        λ = y_t[3]
        SIR_next = λ * np.array([-1.0, 1.0, 0.0]) * S * I / N + np.array(
            [0, -model.mu * I, model.mu * I]
        )
        return np.append(SIR_next, 0)

    log.info("SIR")
    # ------------------------------------------------------------------------------ #
    # Preliminar parameters
    # ------------------------------------------------------------------------------ #
    λ_t = lambda_t

    S_0 = model.initials["SIR"]["S"]
    I_0 = model.initials["SIR"]["I"]
    R_0 = model.initials["SIR"]["R"]

    N = S_0 + I_0 + R_0

    t = np.arange(start=0, stop=model.data_len, step=model.dt)
    # Array for state vectors, already filled for the time 0
    y_t = [np.array([S_0, I_0, R_0, λ_t[0]])]

    # ------------------------------------------------------------------------------ #
    # Timesteps
    # ------------------------------------------------------------------------------ #
    for i in range(len(t) - 1):  # -1 because we append to an array
        """
        RungeKutta4 returns state vector but the last entry (lambda) has to be 
        discarded
        """
        y_t.append(RungeKutta4(model.dt, f, t[i], y_t[i]))
        y_t[i + 1][3] = λ_t[i + 1]

    y_t = np.array(y_t)
    return t, y_t[:, 0], y_t[:, 1], y_t[:, 2]


@use_model_ctx
def SEIR(lambda_t, epsilon=None, gamma=None, model=None):
    """
        Calculates the timeseries for the SEIR model by using Runge Kutta 4.

        Parameters
        ----------
        lambda_t : array
            Should be generated by one of the model lambda functions for the right size
        model : model
            The dummy model to use. Can be none for the last used model

        Return
        ------
        t , S, E, I, R
    """

    def f(t, y_t):
        """
            Function to compute the SEIR model without deaths at time
            t.

            Parameters
            ----------
            t : time t
                not needed but here for consistency in RK4
            y : state_vector
                containing S_t,E_t,I_t,R_t,λ_t

            TODO
            ----
            gamma
            alpha
        """
        S = y_t[0]
        E = y_t[1]
        I = y_t[2]
        R = y_t[3]
        λ = y_t[4]

        dS = -λ * S * I / N
        dE = λ * S * I / N - ε * E
        dI = ε * E - γ * I
        dR = γ * I
        return np.array([dS, dE, dI, dR, 0])

    # ------------------------------------------------------------------------------ #
    # Preliminar parameters
    # ------------------------------------------------------------------------------ #
    λ_t = lambda_t
    S_0 = model.initials["SEIR"]["S"]
    E_0 = model.initials["SEIR"]["E"]
    I_0 = model.initials["SEIR"]["I"]
    R_0 = model.initials["SEIR"]["R"]
    N = S_0 + E_0 + I_0 + R_0

    if gamma is None:
        γ = model.initials["SEIR"]["gamma"]
    else:
        γ = gamma
    if epsilon is None:
        ε = model.initials["SEIR"]["epsilon"]
    else:
        ε = epsilon

    # Time array
    t = np.arange(start=0, stop=model.data_len, step=model.dt)
    # Array for state vectors, already filled for the time 0
    y_t = [np.array([S_0, E_0, I_0, R_0, λ_t[0]])]

    # ------------------------------------------------------------------------------ #
    # Timesteps
    # ------------------------------------------------------------------------------ #
    for i in range(len(t) - 1):  # -1 because we append to an array
        """
        RungeKutta4 returns state vector but the last entry (lambda) has to be 
        discarded
        """
        y_t.append(RungeKutta4(model.dt, f, t[i], y_t[i]))
        y_t[i + 1][4] = λ_t[i + 1]

    y_t = np.array(y_t)
    return t, y_t[:, 0], y_t[:, 1], y_t[:, 2], y_t[:, 3]
